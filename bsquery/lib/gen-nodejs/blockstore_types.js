//
// Autogenerated by Thrift Compiler (0.9.2)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var thrift = require('thrift');
var Thrift = thrift.Thrift;
var Q = thrift.Q;


var ttypes = module.exports = {};
if (typeof blockstore === 'undefined') {
  blockstore = {};
}
ttypes.Network = {
  'BITCOIN' : 1,
  'LITECOIN' : 2,
  'DOGECOIN' : 3,
  'DARKCOIN' : 4
};
ttypes.InvType = {
  'TX' : 1,
  'BLOCK' : 2
};
blockstore.AppException = module.exports.AppException = function(args) {
  Thrift.TException.call(this, "blockstore.AppException")
  this.name = "blockstore.AppException"
  this.code = null;
  this.message = '';
  if (args) {
    if (args.code !== undefined) {
      this.code = args.code;
    }
    if (args.message !== undefined) {
      this.message = args.message;
    }
  }
};
Thrift.inherits(blockstore.AppException, Thrift.TException);
blockstore.AppException.prototype.name = 'AppException';
blockstore.AppException.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.code = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.AppException.prototype.write = function(output) {
  output.writeStructBegin('AppException');
  if (this.code !== null && this.code !== undefined) {
    output.writeFieldBegin('code', Thrift.Type.STRING, 1);
    output.writeString(this.code);
    output.writeFieldEnd();
  }
  if (this.message !== null && this.message !== undefined) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 2);
    output.writeString(this.message);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.NotFound = module.exports.NotFound = function(args) {
  Thrift.TException.call(this, "blockstore.NotFound")
  this.name = "blockstore.NotFound"
  this.message = 'not_found';
  if (args) {
    if (args.message !== undefined) {
      this.message = args.message;
    }
  }
};
Thrift.inherits(blockstore.NotFound, Thrift.TException);
blockstore.NotFound.prototype.name = 'NotFound';
blockstore.NotFound.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.NotFound.prototype.write = function(output) {
  output.writeStructBegin('NotFound');
  if (this.message !== null && this.message !== undefined) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 1);
    output.writeString(this.message);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.Verification = module.exports.Verification = function(args) {
  this.verified = null;
  this.message = null;
  if (args) {
    if (args.verified !== undefined) {
      this.verified = args.verified;
    }
    if (args.message !== undefined) {
      this.message = args.message;
    }
  }
};
blockstore.Verification.prototype = {};
blockstore.Verification.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.verified = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.Verification.prototype.write = function(output) {
  output.writeStructBegin('Verification');
  if (this.verified !== null && this.verified !== undefined) {
    output.writeFieldBegin('verified', Thrift.Type.BOOL, 1);
    output.writeBool(this.verified);
    output.writeFieldEnd();
  }
  if (this.message !== null && this.message !== undefined) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 2);
    output.writeString(this.message);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.Block = module.exports.Block = function(args) {
  this.nettype = null;
  this.hash = null;
  this.version = null;
  this.prevHash = null;
  this.merkleRoot = null;
  this.isMain = null;
  this.nextHash = null;
  this.cntTxes = null;
  this.height = null;
  this.timestamp = null;
  this.objId = null;
  this.bits = null;
  if (args) {
    if (args.nettype !== undefined) {
      this.nettype = args.nettype;
    }
    if (args.hash !== undefined) {
      this.hash = args.hash;
    }
    if (args.version !== undefined) {
      this.version = args.version;
    }
    if (args.prevHash !== undefined) {
      this.prevHash = args.prevHash;
    }
    if (args.merkleRoot !== undefined) {
      this.merkleRoot = args.merkleRoot;
    }
    if (args.isMain !== undefined) {
      this.isMain = args.isMain;
    }
    if (args.nextHash !== undefined) {
      this.nextHash = args.nextHash;
    }
    if (args.cntTxes !== undefined) {
      this.cntTxes = args.cntTxes;
    }
    if (args.height !== undefined) {
      this.height = args.height;
    }
    if (args.timestamp !== undefined) {
      this.timestamp = args.timestamp;
    }
    if (args.objId !== undefined) {
      this.objId = args.objId;
    }
    if (args.bits !== undefined) {
      this.bits = args.bits;
    }
  }
};
blockstore.Block.prototype = {};
blockstore.Block.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.nettype = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.hash = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.version = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.prevHash = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.merkleRoot = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.BOOL) {
        this.isMain = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRING) {
        this.nextHash = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.I32) {
        this.cntTxes = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.I32) {
        this.height = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.I32) {
        this.timestamp = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.STRING) {
        this.objId = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.I64) {
        this.bits = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.Block.prototype.write = function(output) {
  output.writeStructBegin('Block');
  if (this.nettype !== null && this.nettype !== undefined) {
    output.writeFieldBegin('nettype', Thrift.Type.I32, 1);
    output.writeI32(this.nettype);
    output.writeFieldEnd();
  }
  if (this.hash !== null && this.hash !== undefined) {
    output.writeFieldBegin('hash', Thrift.Type.STRING, 2);
    output.writeBinary(this.hash);
    output.writeFieldEnd();
  }
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.I32, 3);
    output.writeI32(this.version);
    output.writeFieldEnd();
  }
  if (this.prevHash !== null && this.prevHash !== undefined) {
    output.writeFieldBegin('prevHash', Thrift.Type.STRING, 4);
    output.writeBinary(this.prevHash);
    output.writeFieldEnd();
  }
  if (this.merkleRoot !== null && this.merkleRoot !== undefined) {
    output.writeFieldBegin('merkleRoot', Thrift.Type.STRING, 5);
    output.writeBinary(this.merkleRoot);
    output.writeFieldEnd();
  }
  if (this.isMain !== null && this.isMain !== undefined) {
    output.writeFieldBegin('isMain', Thrift.Type.BOOL, 6);
    output.writeBool(this.isMain);
    output.writeFieldEnd();
  }
  if (this.nextHash !== null && this.nextHash !== undefined) {
    output.writeFieldBegin('nextHash', Thrift.Type.STRING, 7);
    output.writeBinary(this.nextHash);
    output.writeFieldEnd();
  }
  if (this.cntTxes !== null && this.cntTxes !== undefined) {
    output.writeFieldBegin('cntTxes', Thrift.Type.I32, 8);
    output.writeI32(this.cntTxes);
    output.writeFieldEnd();
  }
  if (this.height !== null && this.height !== undefined) {
    output.writeFieldBegin('height', Thrift.Type.I32, 9);
    output.writeI32(this.height);
    output.writeFieldEnd();
  }
  if (this.timestamp !== null && this.timestamp !== undefined) {
    output.writeFieldBegin('timestamp', Thrift.Type.I32, 10);
    output.writeI32(this.timestamp);
    output.writeFieldEnd();
  }
  if (this.objId !== null && this.objId !== undefined) {
    output.writeFieldBegin('objId', Thrift.Type.STRING, 11);
    output.writeBinary(this.objId);
    output.writeFieldEnd();
  }
  if (this.bits !== null && this.bits !== undefined) {
    output.writeFieldBegin('bits', Thrift.Type.I64, 12);
    output.writeI64(this.bits);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.TxInput = module.exports.TxInput = function(args) {
  this.hash = null;
  this.vout = null;
  this.script = null;
  this.address = null;
  this.amountSatoshi = null;
  this.q = null;
  if (args) {
    if (args.hash !== undefined) {
      this.hash = args.hash;
    }
    if (args.vout !== undefined) {
      this.vout = args.vout;
    }
    if (args.script !== undefined) {
      this.script = args.script;
    }
    if (args.address !== undefined) {
      this.address = args.address;
    }
    if (args.amountSatoshi !== undefined) {
      this.amountSatoshi = args.amountSatoshi;
    }
    if (args.q !== undefined) {
      this.q = args.q;
    }
  }
};
blockstore.TxInput.prototype = {};
blockstore.TxInput.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.hash = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.vout = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.script = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.address = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.amountSatoshi = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I64) {
        this.q = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.TxInput.prototype.write = function(output) {
  output.writeStructBegin('TxInput');
  if (this.hash !== null && this.hash !== undefined) {
    output.writeFieldBegin('hash', Thrift.Type.STRING, 1);
    output.writeBinary(this.hash);
    output.writeFieldEnd();
  }
  if (this.vout !== null && this.vout !== undefined) {
    output.writeFieldBegin('vout', Thrift.Type.I32, 2);
    output.writeI32(this.vout);
    output.writeFieldEnd();
  }
  if (this.script !== null && this.script !== undefined) {
    output.writeFieldBegin('script', Thrift.Type.STRING, 3);
    output.writeBinary(this.script);
    output.writeFieldEnd();
  }
  if (this.address !== null && this.address !== undefined) {
    output.writeFieldBegin('address', Thrift.Type.STRING, 4);
    output.writeString(this.address);
    output.writeFieldEnd();
  }
  if (this.amountSatoshi !== null && this.amountSatoshi !== undefined) {
    output.writeFieldBegin('amountSatoshi', Thrift.Type.STRING, 5);
    output.writeString(this.amountSatoshi);
    output.writeFieldEnd();
  }
  if (this.q !== null && this.q !== undefined) {
    output.writeFieldBegin('q', Thrift.Type.I64, 6);
    output.writeI64(this.q);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.TxOutput = module.exports.TxOutput = function(args) {
  this.address = null;
  this.amountSatoshi = null;
  this.script = null;
  if (args) {
    if (args.address !== undefined) {
      this.address = args.address;
    }
    if (args.amountSatoshi !== undefined) {
      this.amountSatoshi = args.amountSatoshi;
    }
    if (args.script !== undefined) {
      this.script = args.script;
    }
  }
};
blockstore.TxOutput.prototype = {};
blockstore.TxOutput.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.address = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.amountSatoshi = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.script = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.TxOutput.prototype.write = function(output) {
  output.writeStructBegin('TxOutput');
  if (this.address !== null && this.address !== undefined) {
    output.writeFieldBegin('address', Thrift.Type.STRING, 1);
    output.writeString(this.address);
    output.writeFieldEnd();
  }
  if (this.amountSatoshi !== null && this.amountSatoshi !== undefined) {
    output.writeFieldBegin('amountSatoshi', Thrift.Type.STRING, 2);
    output.writeString(this.amountSatoshi);
    output.writeFieldEnd();
  }
  if (this.script !== null && this.script !== undefined) {
    output.writeFieldBegin('script', Thrift.Type.STRING, 3);
    output.writeBinary(this.script);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.Tx = module.exports.Tx = function(args) {
  this.nettype = null;
  this.hash = null;
  this.version = null;
  this.block = null;
  this.blockIndex = null;
  this.objId = null;
  this.inputs = [];
  this.outputs = [];
  if (args) {
    if (args.nettype !== undefined) {
      this.nettype = args.nettype;
    }
    if (args.hash !== undefined) {
      this.hash = args.hash;
    }
    if (args.version !== undefined) {
      this.version = args.version;
    }
    if (args.block !== undefined) {
      this.block = args.block;
    }
    if (args.blockIndex !== undefined) {
      this.blockIndex = args.blockIndex;
    }
    if (args.objId !== undefined) {
      this.objId = args.objId;
    }
    if (args.inputs !== undefined) {
      this.inputs = args.inputs;
    }
    if (args.outputs !== undefined) {
      this.outputs = args.outputs;
    }
  }
};
blockstore.Tx.prototype = {};
blockstore.Tx.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.nettype = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.hash = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.version = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.block = new ttypes.Block();
        this.block.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.blockIndex = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.objId = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.LIST) {
        var _size0 = 0;
        var _rtmp34;
        this.inputs = [];
        var _etype3 = 0;
        _rtmp34 = input.readListBegin();
        _etype3 = _rtmp34.etype;
        _size0 = _rtmp34.size;
        for (var _i5 = 0; _i5 < _size0; ++_i5)
        {
          var elem6 = null;
          elem6 = new ttypes.TxInput();
          elem6.read(input);
          this.inputs.push(elem6);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.LIST) {
        var _size7 = 0;
        var _rtmp311;
        this.outputs = [];
        var _etype10 = 0;
        _rtmp311 = input.readListBegin();
        _etype10 = _rtmp311.etype;
        _size7 = _rtmp311.size;
        for (var _i12 = 0; _i12 < _size7; ++_i12)
        {
          var elem13 = null;
          elem13 = new ttypes.TxOutput();
          elem13.read(input);
          this.outputs.push(elem13);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.Tx.prototype.write = function(output) {
  output.writeStructBegin('Tx');
  if (this.nettype !== null && this.nettype !== undefined) {
    output.writeFieldBegin('nettype', Thrift.Type.I32, 1);
    output.writeI32(this.nettype);
    output.writeFieldEnd();
  }
  if (this.hash !== null && this.hash !== undefined) {
    output.writeFieldBegin('hash', Thrift.Type.STRING, 2);
    output.writeBinary(this.hash);
    output.writeFieldEnd();
  }
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.I32, 3);
    output.writeI32(this.version);
    output.writeFieldEnd();
  }
  if (this.block !== null && this.block !== undefined) {
    output.writeFieldBegin('block', Thrift.Type.STRUCT, 4);
    this.block.write(output);
    output.writeFieldEnd();
  }
  if (this.blockIndex !== null && this.blockIndex !== undefined) {
    output.writeFieldBegin('blockIndex', Thrift.Type.I32, 5);
    output.writeI32(this.blockIndex);
    output.writeFieldEnd();
  }
  if (this.objId !== null && this.objId !== undefined) {
    output.writeFieldBegin('objId', Thrift.Type.STRING, 6);
    output.writeBinary(this.objId);
    output.writeFieldEnd();
  }
  if (this.inputs !== null && this.inputs !== undefined) {
    output.writeFieldBegin('inputs', Thrift.Type.LIST, 7);
    output.writeListBegin(Thrift.Type.STRUCT, this.inputs.length);
    for (var iter14 in this.inputs)
    {
      if (this.inputs.hasOwnProperty(iter14))
      {
        iter14 = this.inputs[iter14];
        iter14.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.outputs !== null && this.outputs !== undefined) {
    output.writeFieldBegin('outputs', Thrift.Type.LIST, 8);
    output.writeListBegin(Thrift.Type.STRUCT, this.outputs.length);
    for (var iter15 in this.outputs)
    {
      if (this.outputs.hasOwnProperty(iter15))
      {
        iter15 = this.outputs[iter15];
        iter15.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.TxVerification = module.exports.TxVerification = function(args) {
  this.verified = null;
  this.message = null;
  if (args) {
    if (args.verified !== undefined) {
      this.verified = args.verified;
    }
    if (args.message !== undefined) {
      this.message = args.message;
    }
  }
};
blockstore.TxVerification.prototype = {};
blockstore.TxVerification.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.verified = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.TxVerification.prototype.write = function(output) {
  output.writeStructBegin('TxVerification');
  if (this.verified !== null && this.verified !== undefined) {
    output.writeFieldBegin('verified', Thrift.Type.BOOL, 1);
    output.writeBool(this.verified);
    output.writeFieldEnd();
  }
  if (this.message !== null && this.message !== undefined) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 2);
    output.writeString(this.message);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.UTXO = module.exports.UTXO = function(args) {
  this.nettype = null;
  this.address = null;
  this.amountSatoshi = null;
  this.txid = null;
  this.vout = null;
  this.confirmations = null;
  this.scriptPubKey = null;
  this.timestamp = null;
  if (args) {
    if (args.nettype !== undefined) {
      this.nettype = args.nettype;
    }
    if (args.address !== undefined) {
      this.address = args.address;
    }
    if (args.amountSatoshi !== undefined) {
      this.amountSatoshi = args.amountSatoshi;
    }
    if (args.txid !== undefined) {
      this.txid = args.txid;
    }
    if (args.vout !== undefined) {
      this.vout = args.vout;
    }
    if (args.confirmations !== undefined) {
      this.confirmations = args.confirmations;
    }
    if (args.scriptPubKey !== undefined) {
      this.scriptPubKey = args.scriptPubKey;
    }
    if (args.timestamp !== undefined) {
      this.timestamp = args.timestamp;
    }
  }
};
blockstore.UTXO.prototype = {};
blockstore.UTXO.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.nettype = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.address = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.amountSatoshi = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.txid = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.vout = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I32) {
        this.confirmations = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRING) {
        this.scriptPubKey = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.I32) {
        this.timestamp = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.UTXO.prototype.write = function(output) {
  output.writeStructBegin('UTXO');
  if (this.nettype !== null && this.nettype !== undefined) {
    output.writeFieldBegin('nettype', Thrift.Type.I32, 1);
    output.writeI32(this.nettype);
    output.writeFieldEnd();
  }
  if (this.address !== null && this.address !== undefined) {
    output.writeFieldBegin('address', Thrift.Type.STRING, 2);
    output.writeString(this.address);
    output.writeFieldEnd();
  }
  if (this.amountSatoshi !== null && this.amountSatoshi !== undefined) {
    output.writeFieldBegin('amountSatoshi', Thrift.Type.STRING, 3);
    output.writeString(this.amountSatoshi);
    output.writeFieldEnd();
  }
  if (this.txid !== null && this.txid !== undefined) {
    output.writeFieldBegin('txid', Thrift.Type.STRING, 4);
    output.writeBinary(this.txid);
    output.writeFieldEnd();
  }
  if (this.vout !== null && this.vout !== undefined) {
    output.writeFieldBegin('vout', Thrift.Type.I32, 5);
    output.writeI32(this.vout);
    output.writeFieldEnd();
  }
  if (this.confirmations !== null && this.confirmations !== undefined) {
    output.writeFieldBegin('confirmations', Thrift.Type.I32, 6);
    output.writeI32(this.confirmations);
    output.writeFieldEnd();
  }
  if (this.scriptPubKey !== null && this.scriptPubKey !== undefined) {
    output.writeFieldBegin('scriptPubKey', Thrift.Type.STRING, 7);
    output.writeBinary(this.scriptPubKey);
    output.writeFieldEnd();
  }
  if (this.timestamp !== null && this.timestamp !== undefined) {
    output.writeFieldBegin('timestamp', Thrift.Type.I32, 8);
    output.writeI32(this.timestamp);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.SendTx = module.exports.SendTx = function(args) {
  this.hash = null;
  this.raw = null;
  this.remoteAddress = null;
  this.sequence = null;
  if (args) {
    if (args.hash !== undefined) {
      this.hash = args.hash;
    }
    if (args.raw !== undefined) {
      this.raw = args.raw;
    }
    if (args.remoteAddress !== undefined) {
      this.remoteAddress = args.remoteAddress;
    }
    if (args.sequence !== undefined) {
      this.sequence = args.sequence;
    }
  }
};
blockstore.SendTx.prototype = {};
blockstore.SendTx.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.hash = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.raw = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.remoteAddress = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.sequence = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.SendTx.prototype.write = function(output) {
  output.writeStructBegin('SendTx');
  if (this.hash !== null && this.hash !== undefined) {
    output.writeFieldBegin('hash', Thrift.Type.STRING, 1);
    output.writeBinary(this.hash);
    output.writeFieldEnd();
  }
  if (this.raw !== null && this.raw !== undefined) {
    output.writeFieldBegin('raw', Thrift.Type.STRING, 2);
    output.writeBinary(this.raw);
    output.writeFieldEnd();
  }
  if (this.remoteAddress !== null && this.remoteAddress !== undefined) {
    output.writeFieldBegin('remoteAddress', Thrift.Type.STRING, 4);
    output.writeString(this.remoteAddress);
    output.writeFieldEnd();
  }
  if (this.sequence !== null && this.sequence !== undefined) {
    output.writeFieldBegin('sequence', Thrift.Type.STRING, 6);
    output.writeString(this.sequence);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.Inventory = module.exports.Inventory = function(args) {
  this.type = null;
  this.hash = null;
  if (args) {
    if (args.type !== undefined) {
      this.type = args.type;
    }
    if (args.hash !== undefined) {
      this.hash = args.hash;
    }
  }
};
blockstore.Inventory.prototype = {};
blockstore.Inventory.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.hash = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.Inventory.prototype.write = function(output) {
  output.writeStructBegin('Inventory');
  if (this.type !== null && this.type !== undefined) {
    output.writeFieldBegin('type', Thrift.Type.I32, 1);
    output.writeI32(this.type);
    output.writeFieldEnd();
  }
  if (this.hash !== null && this.hash !== undefined) {
    output.writeFieldBegin('hash', Thrift.Type.STRING, 2);
    output.writeBinary(this.hash);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.Peer = module.exports.Peer = function(args) {
  this.host = null;
  this.port = null;
  this.time = null;
  this.version = null;
  if (args) {
    if (args.host !== undefined) {
      this.host = args.host;
    }
    if (args.port !== undefined) {
      this.port = args.port;
    }
    if (args.time !== undefined) {
      this.time = args.time;
    }
    if (args.version !== undefined) {
      this.version = args.version;
    }
  }
};
blockstore.Peer.prototype = {};
blockstore.Peer.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.host = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.port = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.time = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.version = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.Peer.prototype.write = function(output) {
  output.writeStructBegin('Peer');
  if (this.host !== null && this.host !== undefined) {
    output.writeFieldBegin('host', Thrift.Type.STRING, 1);
    output.writeString(this.host);
    output.writeFieldEnd();
  }
  if (this.port !== null && this.port !== undefined) {
    output.writeFieldBegin('port', Thrift.Type.I32, 2);
    output.writeI32(this.port);
    output.writeFieldEnd();
  }
  if (this.time !== null && this.time !== undefined) {
    output.writeFieldBegin('time', Thrift.Type.I32, 3);
    output.writeI32(this.time);
    output.writeFieldEnd();
  }
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.I32, 4);
    output.writeI32(this.version);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.TxIdListWithCursor = module.exports.TxIdListWithCursor = function(args) {
  this.cursor = null;
  this.txids = null;
  if (args) {
    if (args.cursor !== undefined) {
      this.cursor = args.cursor;
    }
    if (args.txids !== undefined) {
      this.txids = args.txids;
    }
  }
};
blockstore.TxIdListWithCursor.prototype = {};
blockstore.TxIdListWithCursor.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.cursor = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        var _size16 = 0;
        var _rtmp320;
        this.txids = [];
        var _etype19 = 0;
        _rtmp320 = input.readListBegin();
        _etype19 = _rtmp320.etype;
        _size16 = _rtmp320.size;
        for (var _i21 = 0; _i21 < _size16; ++_i21)
        {
          var elem22 = null;
          elem22 = input.readBinary();
          this.txids.push(elem22);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.TxIdListWithCursor.prototype.write = function(output) {
  output.writeStructBegin('TxIdListWithCursor');
  if (this.cursor !== null && this.cursor !== undefined) {
    output.writeFieldBegin('cursor', Thrift.Type.STRING, 1);
    output.writeBinary(this.cursor);
    output.writeFieldEnd();
  }
  if (this.txids !== null && this.txids !== undefined) {
    output.writeFieldBegin('txids', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRING, this.txids.length);
    for (var iter23 in this.txids)
    {
      if (this.txids.hasOwnProperty(iter23))
      {
        iter23 = this.txids[iter23];
        output.writeBinary(iter23);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.AddressListWithCursor = module.exports.AddressListWithCursor = function(args) {
  this.cursor = null;
  this.addresses = null;
  if (args) {
    if (args.cursor !== undefined) {
      this.cursor = args.cursor;
    }
    if (args.addresses !== undefined) {
      this.addresses = args.addresses;
    }
  }
};
blockstore.AddressListWithCursor.prototype = {};
blockstore.AddressListWithCursor.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.cursor = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        var _size24 = 0;
        var _rtmp328;
        this.addresses = [];
        var _etype27 = 0;
        _rtmp328 = input.readListBegin();
        _etype27 = _rtmp328.etype;
        _size24 = _rtmp328.size;
        for (var _i29 = 0; _i29 < _size24; ++_i29)
        {
          var elem30 = null;
          elem30 = input.readString();
          this.addresses.push(elem30);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.AddressListWithCursor.prototype.write = function(output) {
  output.writeStructBegin('AddressListWithCursor');
  if (this.cursor !== null && this.cursor !== undefined) {
    output.writeFieldBegin('cursor', Thrift.Type.STRING, 1);
    output.writeBinary(this.cursor);
    output.writeFieldEnd();
  }
  if (this.addresses !== null && this.addresses !== undefined) {
    output.writeFieldBegin('addresses', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRING, this.addresses.length);
    for (var iter31 in this.addresses)
    {
      if (this.addresses.hasOwnProperty(iter31))
      {
        iter31 = this.addresses[iter31];
        output.writeString(iter31);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.AddrStat = module.exports.AddrStat = function(args) {
  this.address = null;
  this.cntTxes = null;
  this.receivedSatoshi = null;
  this.balanceSatoshi = null;
  if (args) {
    if (args.address !== undefined) {
      this.address = args.address;
    }
    if (args.cntTxes !== undefined) {
      this.cntTxes = args.cntTxes;
    }
    if (args.receivedSatoshi !== undefined) {
      this.receivedSatoshi = args.receivedSatoshi;
    }
    if (args.balanceSatoshi !== undefined) {
      this.balanceSatoshi = args.balanceSatoshi;
    }
  }
};
blockstore.AddrStat.prototype = {};
blockstore.AddrStat.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.address = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.cntTxes = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.receivedSatoshi = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.balanceSatoshi = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.AddrStat.prototype.write = function(output) {
  output.writeStructBegin('AddrStat');
  if (this.address !== null && this.address !== undefined) {
    output.writeFieldBegin('address', Thrift.Type.STRING, 1);
    output.writeString(this.address);
    output.writeFieldEnd();
  }
  if (this.cntTxes !== null && this.cntTxes !== undefined) {
    output.writeFieldBegin('cntTxes', Thrift.Type.I32, 2);
    output.writeI32(this.cntTxes);
    output.writeFieldEnd();
  }
  if (this.receivedSatoshi !== null && this.receivedSatoshi !== undefined) {
    output.writeFieldBegin('receivedSatoshi', Thrift.Type.STRING, 3);
    output.writeString(this.receivedSatoshi);
    output.writeFieldEnd();
  }
  if (this.balanceSatoshi !== null && this.balanceSatoshi !== undefined) {
    output.writeFieldBegin('balanceSatoshi', Thrift.Type.STRING, 4);
    output.writeString(this.balanceSatoshi);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

blockstore.AddrTxId = module.exports.AddrTxId = function(args) {
  this.address = null;
  this.txid = null;
  this.inputSatoshi = null;
  this.outputSatoshi = null;
  this.cursor = null;
  if (args) {
    if (args.address !== undefined) {
      this.address = args.address;
    }
    if (args.txid !== undefined) {
      this.txid = args.txid;
    }
    if (args.inputSatoshi !== undefined) {
      this.inputSatoshi = args.inputSatoshi;
    }
    if (args.outputSatoshi !== undefined) {
      this.outputSatoshi = args.outputSatoshi;
    }
    if (args.cursor !== undefined) {
      this.cursor = args.cursor;
    }
  }
};
blockstore.AddrTxId.prototype = {};
blockstore.AddrTxId.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.address = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.txid = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.inputSatoshi = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.outputSatoshi = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.cursor = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

blockstore.AddrTxId.prototype.write = function(output) {
  output.writeStructBegin('AddrTxId');
  if (this.address !== null && this.address !== undefined) {
    output.writeFieldBegin('address', Thrift.Type.STRING, 1);
    output.writeString(this.address);
    output.writeFieldEnd();
  }
  if (this.txid !== null && this.txid !== undefined) {
    output.writeFieldBegin('txid', Thrift.Type.STRING, 2);
    output.writeBinary(this.txid);
    output.writeFieldEnd();
  }
  if (this.inputSatoshi !== null && this.inputSatoshi !== undefined) {
    output.writeFieldBegin('inputSatoshi', Thrift.Type.STRING, 3);
    output.writeString(this.inputSatoshi);
    output.writeFieldEnd();
  }
  if (this.outputSatoshi !== null && this.outputSatoshi !== undefined) {
    output.writeFieldBegin('outputSatoshi', Thrift.Type.STRING, 4);
    output.writeString(this.outputSatoshi);
    output.writeFieldEnd();
  }
  if (this.cursor !== null && this.cursor !== undefined) {
    output.writeFieldBegin('cursor', Thrift.Type.STRING, 5);
    output.writeBinary(this.cursor);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

